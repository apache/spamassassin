#!/usr/bin/perl -w
# This script isn't supposed to be run by hand, it's used by `make` as a pre-
# processor. It currently accepts these options on the command line:
#
#   -M<module>            Enables <module>
#   -D<variable>=<value>  Defines the <variable> to be <value>
#
# and some more to help with non-UNIX platforms, where command-line input
# and output redirection are not always available:
#
#   -i<file>              Read from input file <file>
#   -o<file>              Write to output file <file>
#
#   -I<dir>               Read from input directory <dir>
#   -O<dir>               Write to output directory <dir>
#   <filename> ...        Process named files from -I<dir> to -O<dir>
#
# Those modules are currently implemented:
#   conditional          Comments out every line containing the string
#                        REMOVEFORINST
#   vars                 Replaces variables: upper case strings surrounded
#                        by double at-signs, eg. @@VERSION@@. The values are
#                        taken from the environment and can be overwritten with
#                        the -D switch. Empty/undefined variables are removed.
#   sharpbang            Does some sharpbang (#!) replacement. See code below.

use Config;
use File::Spec;

my %modules = ();
my %defines = ();
my @infiles = ();
my $indir;
my $outdir;

foreach (keys %ENV) {
  $defines{$_} = $ENV{$_};
}

foreach (@ARGV) {
  if    (/^-M([a-z]+)$/)       { $modules{$1} = 1; }
  elsif (/^-D([A-Z_]+)=(.*)$/) { $defines{$1} = $2; }
  elsif (/^-i(.+)$/) { $infile = $1; }
  elsif (/^-o(.+)$/) { $outfile = $1; }
  elsif (/^-I(.+)$/) { $indir = $1; }
  elsif (/^-O(.+)$/) { $outdir = $1; }
  elsif (/^(.+)$/) { push (@infiles, $1); }
}

my $l = 1;
my $fname;
if (defined ($indir) && defined ($outdir) && scalar @infiles > 0) {
  while ($fname = shift @infiles) {
    my $in = File::Spec->catfile ($indir, $fname);
    my $out = File::Spec->catfile ($outdir, $fname);
    do_file ($in, $out);
  }
}

elsif (defined ($infile) && defined($outfile)) {
  do_file ($infile, $outfile);
}

else {
  # just do STDIN/STDOUT . Not recommended for portability as
  # it requires "<" and ">" for Makefile to do its work.
  #
  do_stdin();
}

sub do_file {
  my ($in, $out) = @_;
  open (STDIN, "<$in") or die "cannot open $in";
  open (OUT, ">$out") or die "cannot open $out"; select OUT;
  do_stdin();
  close STDIN; close OUT;
}

sub do_stdin {
  while (<STDIN>) {
    $_ = pack("C0A*", $_);	# turn off UTF8-ness

    # Conditional compiling
    if ($modules{'conditional'}) {
      # Comment out lines carrying the REMOVEFORINST tag
      if(/\bREMOVEFORINST\b/) {
        s/^(\s*)/$1#/;
        s/REMOVEFORINST/REMOVEDBYINST/;
      }
    }

    # Variable replacement
    if ($modules{'vars'}) {
      # Replace all @@VARS@@
      s/\@\@([A-Z][A-Z0-9_]*)\@\@/$defines{$1}/g;
    }

    # Sharpbang (#!) replacement (see also ExtUtils::MY->fixin)
    if ($modules{'sharpbang'} && ($l == 1)) {
      # The perlpath can be overwritten via -DPERL_BIN=<perlpath>
      my $perl   = $defines{'PERL_BIN'} || $Config{'perlpath'};

      # If we're using a CVS build, add the -w switch to turn on warnings
      my $minusw = -f 'CVS/Repository' ? ' -w' : '';

      # The warnings can be overwritten via -DPERL_WARN=<1|0>
      if (defined $defines{'PERL_WARN'}) {
        $minusw = $defines{'PERL_WARN'} ? ' -w' : '';
      }
      s/^#!.*perl.*$/#!${perl}${minusw}/;
    }

    print;
    $l++;
  }
}
