#!/usr/bin/perl -w

############################################################
# The code in this file is copyright 2001 by Craig Hughes  #
# It is licensed for use with the SpamAssassin distribution#
# under the terms of the Perl Artistic License, the text of#
# which is included as the file named "License"            #
############################################################

use lib '../lib';	# added by jm for use inside the distro
use strict;
use Socket;
use Carp;
use Mail::Audit;
use Mail::SpamAssassin;
use Sys::Syslog qw(:DEFAULT setlogsock);
use POSIX qw(setsid);

my $spamtest = Mail::SpamAssassin->new({
  # maybe turned on by a command-line arg?
  #	local_tests_only=>1
  dont_copy_prefs => 1
});
$spamtest->init();


my %resphash = (
    EX_OK => 0,
    EX_USAGE => 64, # command line usage error
    EX_DATAERR => 65, # data format error
    EX_NOINPUT => 66, # cannot open input
    EX_NOUSER => 67, # addressee unknown
    EX_NOHOST => 68, # host name unknown
    EX_UNAVAILABLE => 69, # service unavailable
    EX_SOFTWARE => 70, # internal software error
    EX_OSERR => 71, # system error (e.g., can't fork)
    EX_OSFILE => 72, # critical OS file missing
    EX_CANTCREAT => 73, # can't create (user) output file
    EX_IOERR => 74, # input/output error
    EX_TEMPFAIL => 75, # temp failure; user is invited to retry
    EX_PROTOCOL => 76, # remote error in protocol
    EX_NOPERM => 77, # permission denied
    EX_CONFIG => 78, # configuration error
);

sub spawn;  # forward declaration
setlogsock('unix');
sub logmsg { openlog('spamd','cons,pid','mail'); syslog('info',"@_"); closelog(); }

my $port = shift || 22874;
my $proto = getprotobyname('tcp');

($port) = $port =~ /^(\d+)$/ or die "invalid port";

# Be a well-behaved daemon
chdir '/'               or die "Can't chdir to /: $!";
open STDIN, '/dev/null' or die "Can't read /dev/null: $!";
open STDOUT, '>/dev/null' or die "Can't write to /dev/null: $!";
open STDERR, '>/dev/null' or die "Can't write to /dev/null: $!";

socket(Server, PF_INET, SOCK_STREAM, $proto)        || die "socket: $!";
setsockopt(Server,SOL_SOCKET,SO_REUSEADDR,pack("l", 1)) || die "setsockopt: $!";
bind(Server, sockaddr_in($port, INADDR_ANY))        || die "bind: $!";
listen(Server,SOMAXCONN)                            || die "listen: $!";

logmsg "server started on port $port";

my $waitedpid = 0;
my $paddr;

sub REAPER {
    $waitedpid = wait;
    $SIG{CHLD} = \&REAPER;  # loathe sysV
}

$SIG{CHLD} = \&REAPER;

for ( $waitedpid = 0;
      ($paddr = accept(Client,Server)) || $waitedpid;
      $waitedpid = 0, close Client)
{
    next if $waitedpid and not $paddr;

    my($port,$iaddr) = sockaddr_in($paddr);
    my $name = gethostbyaddr($iaddr,AF_INET);
    logmsg "connection from $name [",inet_ntoa($iaddr),"] at port $port";

    spawn sub {
	$|=1; # always immediately flush output
	# First request line off stream
        $_ = <STDIN>;
	chomp;
        if(/PROCESS SPAMC\/(.*)/)
	{
	    my $version = $1;
	    if($version > 1.0)
	    {
		while(1)
		{
		    $_ = <STDIN>;
		    if(/^\r\n/) { last; }
		    if(/^User: (.*)\r\n/)
		    {
			my $username = $1;
			my @pw = getpwnam($username);
			my $dir = $pw[7];
			if(-f "$dir/.spamassassin.cf")
			{
			    open (PREFS,"<$dir/.spamassassin.cf");
			    $spamtest->{conf}->parse_rules(join('',<PREFS>));
			    close(PREFS);
			}
		    }
		}
	    }
	    my $resp = "EX_OK";
	    # Now read in message
	    my $mail = Mail::Audit->new();

	    # Parse user scores:
	    # $spamtest->read_scoresonly_config
	    #			(username_to_prefs_file ($username));

	    # Now use copy-on-writed (hopefully) SA object
	    my $status = $spamtest->check($mail);
	    $status->rewrite_mail; #if $status->is_spam;

	    print "SPAMD/1.0 $resphash{$resp} $resp\r\n",$mail->header,"\n",(join '',@{$mail->body});

	    logmsg "processed successfully";

	    $status->finish();	# added by jm to allow GC'ing
	}
	else
	{
	    my $resp = "EX_PROTOCOL";
	    print "SPAMD/1.0 $resphash{$resp} Bad header line: $_\r\n";
	    logmsg "bad protocol: header error: $_";
	}
    };

}

sub spawn {
    my $coderef = shift;

    unless (@_ == 0 && $coderef && ref($coderef) eq 'CODE') {
	confess "usage: spawn CODEREF";
    }

    my $pid;
    if (!defined($pid = fork)) {
	logmsg "cannot fork: $!";
	return;
    } elsif ($pid) {
	return; # I'm the parent
    }
    # else I'm the child -- go spawn

    open(STDIN,  "<&Client")   || die "can't dup client to stdin";
    open(STDOUT, ">&Client")   || die "can't dup client to stdout";
    exit &$coderef();
}

# e.g. "jm" -> "/home/jm/.spamassassin.prefs"
#
sub username_to_prefs_file {
  my $user = shift;
  my ($name,$pwd,$uid,$gid,$quota,$cmt,$gcos,$dir,$etc) = getpwnam ($user);
  return "$dir/.spamassassin.prefs";
}

=head1 NAME

spamd - daemonized version of spamassassin

=head1 SYNOPSIS

spamd [port]

=head1 OPTIONS

=over

=item I<port>

Optionally specifies the port number for the server to listen on

=back

=head1 DESCRIPTION

The purpose of this program is to provide a daemonized version of the
spamassassin executable.  The goal is improving throughput performance for
automated mail checking.

This is intended to be used alongside C<spamc>, a fast, low-overhead C client
program.

See the README file in the C<spamd> directory of the SpamAssassin distribution
for more details.

=head1 SEE ALSO

spamc(1)
spamassassin(1)
Mail::SpamAssassin(3)

=head1 AUTHOR

Craig R Hughes E<lt>craig@hughes-family.orgE<gt>

=head1 PREREQUISITES

C<Mail::SpamAssassin>

=cut

